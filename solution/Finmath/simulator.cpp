#include "stdafx.h"
#include <random>
#include <fstream>
#include "simulator.h"



using namespace finmath;

namespace finmath {

	NormalDistribution::NormalDistribution(double mean, double stddev, int seed) {	
		setup(mean, stddev, seed); 
	}
	NormalDistribution::NormalDistribution(int seed) {
		setup(0.0, 1.0, seed);
	}
	void NormalDistribution::setup(double mean, double stddev, int seed) {
		generator_ = seed != NULL ? std::default_random_engine((unsigned int)seed) : std::default_random_engine();
		distribution_ = std::normal_distribution<double>(mean, stddev);
	}

	double NormalDistribution::nextValue() {
		return distribution_(generator_);
	}

	CorrelationGenerator::CorrelationGenerator(CorrelationMatrix& matrix, RandomGenerator& generator) : 
		correlation_matrix_(matrix), 
		generator_(generator),
		distribution_(Matrix( matrix.rows(), 1)) 
	{
		next_sample();
	};

	void CorrelationGenerator::next_sample(void) {

		// generate the independent values first
		for( int i = 0; i < correlation_matrix_.rows(); i++ ) {
			distribution_(i) = generator_.nextValue();
		}
		// use the lower triangular matrix generated by Cholesky decomposition
		// to get correlated values
		distribution_ = correlation_matrix_ * distribution_;
	}

	double CorrelationGenerator::wiener(int index) { 
		return distribution_(index);
	}

	Share::Share(std::string name, std::string currency, double initial_price, double drift, double volatility) :
		name_(name), 
		currency_(currency), 
		initial_price_(initial_price),
		sigma_(volatility),
		mu_(drift),
		nu_(drift-sigma_*sigma_/2)
	{}

	Share::Share( const Share& share ) {
		name_ = share.name_;
		currency_ = share.currency_;
		initial_price_ = share.initial_price_;
		sigma_ = share.sigma_;
		mu_ = share.mu_;
		nu_ = share.nu_;
	}

	Share::~Share(void) {}

	void Share::update_current_price(double time, double wiener_process){
		current_price_ = initial_price_ * exp(nu_ * time + sigma_ * sqrt(time) * wiener_process);
	}

	std::ostream& operator<<(std::ostream &strm, const Share &share) {
		return strm << 
			share.name_ << ": " << share.initial_price_ << share.currency_ << 
			" drift:" << share.mu_ << 
			" volatility:" << share.sigma_;  
	}

	Simulator::Simulator(ContractCalendar& calendar, double notional_amount, double short_interest_rate, std::vector<Share> &basket, double knock_in_percentage, CorrelationGenerator& correlation_generator) : 
		calendar_(calendar),
		notional_amount_(notional_amount),
		short_interest_rate_(short_interest_rate),
		basket_(basket), 
		knock_in_percentage_(knock_in_percentage),
		correlation_generator_(correlation_generator),
		sample_count_(10000),
		stored_iteration_index_(-1),
		check_knock_in_event_(true),
		jump_to_final_date_(true),
		suppress_party_A_payments_(false),
		suppress_party_B_payments_(false)
	{}

	Simulator::~Simulator(void) {}

	void Simulator::set_sample_count(int count){
		sample_count_ = count;
	}

	// currency conversion is not used in the test since the currency rate is constant and 
	// equity amounts are calculated in USD: $400.00 * percentage 

	//double Simulator::currency_rate(std::string currency1, std::string currency2, double time){
	//	if ((currency1.compare("USD")==0) & (currency2.compare("HKD")==0))
	//		return 7.76;
	//	throw std::exception( "Unsupported currency" );
	//}

	double Simulator::least_performing_share(std::vector<Share> &basket) {
		std::vector<double> performance_level(basket_.size());
		for (unsigned int i = 0; i < basket_.size(); i++)
			performance_level[i] = basket_[i].performance_level();
		return *std::min_element(performance_level.begin(), performance_level.end());
	}

	// The equity amount determination logic seems be a combination of two options: 
	//    Europian call option (Party B), and
	//    Down-and-In option (Party A)
	double Simulator::determine_equity_amount(double lps, bool knocked_in){
		double performance;
		// Party A pays to party B if knock-in event hasn't happened
		if (!knocked_in)
			performance = std::max(lps - 1.0, 0.0);
		// Party A pays to Party B if knock-in event happened and the final LPS is more than 100%
		// Party B pays to party A if knock-in event happened and the final LPS is less than 100%
		else
			performance = lps - 1.0;
		if ( (performance > 0 && suppress_party_A_payments_) || (performance < 0 && suppress_party_B_payments_)){
			performance = 0;
		}
		return notional_amount_ * performance;
	}

	// Simulates share prices from the start day till the end of contract
	// 
	// 'performed_steps_count' and 'store_data' parameters are used to display
	// the interim simulation process status and the generated prices to the user
	double Simulator::equity_amount_sample(int* performed_steps_count, bool store_data){

		CalendarItems steps = calendar_.get_calendar_items();

		bool knocked_in = false;
		bool knocked_in_processed = false;
		double lps;
		int i = 0;
		for (std::list<TimePeriodItem*>::iterator it = steps.begin(); it != steps.end() && !knocked_in_processed; ++it, i++){		
			double time = (*it)->deltaT;

			// jump to final date if the knock-in event has happened
			if (knocked_in && jump_to_final_date_){
				time = calendar_.get_contract_deltaT() ;
				knocked_in_processed = true;
			}
			// get the next tuple of the random numbers
			correlation_generator_.next_sample();
			for (unsigned int j = 0; j < basket_.size(); j++) {
				basket_[j].update_current_price(time, correlation_generator_.wiener(j));
			}
			// if saving to .csv file is turned on
			// save the sample data in memory until the the simulation finish
			if (store_data){
				std::vector<double> data(basket_.size() + 1);
				data[0] = time;
				for (unsigned int j = 0; j < basket_.size(); j++) {
					data[j+1] = basket_[j].current_price();
				}
				stored_iteration_data_.push_back(data);
			}

			lps = least_performing_share (basket_);
			// knock-in event checking can be turned off for debugging purpose
			// see sim.check_knock_in_event(bool mode) function 
			if (check_knock_in_event_){
				knocked_in |= lps < knock_in_percentage_;
			}
		}
		*performed_steps_count = i;
		return determine_equity_amount(lps, knocked_in);
	}

	double Simulator::simulate_equity_amount(void){
		double sum = 0;
		for ( int i = 0; i < sample_count_; i++){
			int performed_steps_count;

			// performed_steps_count can be reduced if the knock-in event has happened before the final date.
			// there is no need to simulate the prices between the knock-in event day and the final day
			double simulated_equity_amount = equity_amount_sample(&performed_steps_count, i == stored_iteration_index_);
			sum += simulated_equity_amount;
			std::cout << 
				"iteration:" << std::setw(7) << std::left << i << 
				"steps:" << std::setw(6) << std::left << performed_steps_count << 
				"entity amount:" << simulated_equity_amount <<  std::endl;
		}

		// save one iteration data to .csv file if specified
		if (stored_iteration_index_ >= 0){
			write_iteration_data();
		}
		return sum / sample_count_;
	}

	double Simulator::number_of_periods(void){
		return calendar_.get_contract_deltaT();
	}

	double Simulator::simulate_present_value(void){
		return simulate_equity_amount()  / pow (( 1 + short_interest_rate_), number_of_periods());
	}

	void Simulator::save_iteration_data(int index, std::string file_name){
		stored_iteration_index_ = index;
		data_file_name_ = file_name;
	}

	void Simulator::write_iteration_data(void){
		std::ofstream file;
		file.open(data_file_name_);

		file << "time,'";
		for (unsigned int j = 0; j < basket_.size(); j++) {
			file << basket_[j].name() << ',';
		}
		file << std::endl;
		for (std::vector<std::vector<double>>::iterator it = stored_iteration_data_.begin(); it != stored_iteration_data_.end(); it++) {
			for (unsigned int j = 0; j < (*it).size(); j++) {
				file << (*it)[j] << ',';
			}
			file << std::endl;
		}
		file.close();
		std::cout << "Sample data (iteration " << stored_iteration_index_ << ") stored in '" << data_file_name_ << "' file" << std::endl;
	}

	void Simulator::check_knock_in_event(bool mode){
		check_knock_in_event_ = mode;
	}

	void Simulator::jump_to_final_date(bool mode){
		jump_to_final_date_ = mode;
	}

	void Simulator::suppress_payments(bool suppress_party_A_payments, bool suppress_party_B_payments)
	{
		suppress_party_A_payments_ = suppress_party_A_payments;
		suppress_party_B_payments_ = suppress_party_B_payments;
	}

	std::ostream& operator<<(std::ostream &strm, const Simulator &sim) {
		strm << 
			"notional amount:" << sim.notional_amount_ << std::endl <<
			"short interest rate:" << sim.short_interest_rate_ << std::endl <<
			"sample count:" << sim.sample_count_ << std::endl <<
			"knock in percentage:" << sim.knock_in_percentage_ << std::endl <<
			"Shares:" << std::endl; 
		for( unsigned int i = 0; i < sim.basket_.size(); i++){
			strm << '\t' << sim.basket_[i] << std::endl;
		}
		return strm;
	}
}
